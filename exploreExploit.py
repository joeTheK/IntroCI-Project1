# Joseph Kelley
# Implements three crossover methods and mutation function

import numpy as np
import random
import matplotlib.pyplot as plt

## Exploitation

#3 parent simplex space crossover
#   P1____P3
#    |C  /
#    |  /
# 	 P2/
 
def simplexSpaceCross(popOfParents):
	nextGen = []
	nextGen.append(popOfParents[0])
	for i in range(3, len(popOfParents), 3):
		child = []
		weights = []
		weights.append(random.uniform(0, 1))
		weights.append(random.uniform(0, (1 - weights[0])))
		weights.append(random.uniform(0, (1 - (weights[0] + weights[1]))))

		xArray = [chromosone[0] for chromosone in popOfParents[i:i+3]]
		xMean = sum(xArray) / 3
		yArray = [chromosone[1] for chromosone in popOfParents[i:i+3]]
		yMean = sum(yArray) / 3

		for j in range(3):
			childX = weights[j] * (xArray[j] - xMean)
			childY = weights[j] * (yArray[j] - yMean)
		childX += xMean
		childY += yMean
		child.append(childX)
		child.append(childY)
		nextGen.append(child)

	#Commented below is to print plots showing SPX working
	#ONLY USE ON SMALL POPULATIONS (runs a lot of times)

	#pts1 = np.array(popOfParents[0:3])
	#plt.scatter([x[0] for x in pts1], [y[1] for y in pts1])
	#plt.scatter(nextGen[0][0], nextGen[0][1])
	#plt.scatter(xMean, yMean)
	#plt.savefig('SPXtest3')
	#plt.show()

	return nextGen

#Crossover taken from GA2.py from VCS (used with permission)

def crossover(pop_after_sel,sz):
    population_nextgen = [] 
    population_nextgen.append(pop_after_sel[0])
    for i in range(1,sz):
        child = pop_after_sel[2*i+0].copy()
        parent2 = pop_after_sel[2*i+1].copy()
        loc = np.random.randint(0,1)
        child[loc] = parent2[loc]
        population_nextgen.append(child)
    return population_nextgen

#Average crossover
#Child values are average of 2 parent values

def avgCrossover(popOfParents):
	nextGen = []
	nextGen.append(popOfParents[0])
	for i in range(2, len(popOfParents), 2):
		parent1 = popOfParents[i]
		parent2 = popOfParents[i+1]
		child = []
		child.append((parent1[0] + parent2[0]) / 2)
		child.append((parent1[1] + parent2[1]) / 2)
		nextGen.append(child)
	return nextGen

## Exploration

#Mutation
#Simple random mutation on random axis. For each chromosone,
#gives two chances to mutate, with each coordinate being random.
#If mutated the first time makes it harder to mutate a second time.
#Returns a list of the next generation.

def mutate(pop, mutationRate):
	nextGen = []
	nextGen.append(pop[0])
	for i in range(1, len(pop)):
		didMutate = False
		chromosone = pop[i]
		#runs twice
		for j in range(2):
			toMutate = random.randrange(0, 2)
			if didMutate:
				mutationRate = mutationRate - random.uniform(0, 1 - mutationRate)
			if random.random() < mutationRate:
				chromosone[toMutate] = ((np.random.random() - 0.5) * 2) * 10
				didMutate = True				
		nextGen.append(chromosone)
	return nextGen